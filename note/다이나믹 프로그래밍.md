# 다이나믹 프로그래밍
- 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시키는 방법
  - DP는 다음 조건을 만족할 때 사용할 수 있다
    - 큰 문제를 작은 문제로 나눌 수 있다.
    - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. 
  - 탑 다운 방식
    - 재귀함수 이용 방법
    - 큰 문제를 해결하기 위해 작은 문제를 호출
    ```python
    # 피보나치 수열 (탑다운 DP)
    d = [0] * 100
    def fibo(x):
        if x == 1 or x == 2 :
            return 1
        if d[x] != 0:
            return d[x]
        d[x] = fibo(x-2) + fibo(x-1)
        return d[x]
    
    print(fibo(99))
    ```
  - 보텀업 방식
    - for문 이용
    - 작은 문제부터 답을 도출 
    ```python
    # 피보나치 수열 (보텀업 DP)
      d = [0] * 100
      
      d[1] = 1
      d[2] = 1
      n = 99
    
      for i in range(3,n+1):
          d[i] = d[i-1] + d[i-2]
          
      print(d[n])
    ```
## 활용
### 냅색 Knapsack
- 짐싸기 문제라고도 한다. 해당 문제는 DP로 풀 수 있는 경우가 많음
- 여러 물건이 있을 때, 특정한 조건을 만족하는 조합을 구하는 문제이다. 
- 관련 문제 : 백준 12865번

- dp 전략
  1. 이중 dp 배열 사용
     - dp[i][j] 
       - 처음부터 i번째 물건을 살펴보고
       - 조건에 해당하는 수치(용량,w)이 j였을 때
       - 배낭에 들어 간 물건이 가진 최대로 만들어야 하는 수치(가치,v)의 최대값을 저장 
     - 점화식 
       - dp[i][j] = max(dp[i-1][j], d[i-1][j-w[i]] + v[i] )
       - 현재 짐을 배낭에 넣을 때와 안 넣을때 중 최대 값을 넣는 것
       - j를 맞춰주기 위해 넣을 때는 해당 무게만큼을 빼줬을 때 용량에 해당하는 가치에 새로운 가치를 더하는 것이 특징이다.
  2. 최적화 ) 1차원 배열 사용
     - 2차원에서는 조건(용량)을 작은 쪽부터 큰 쪽으로 탐색
     - 1차원 dp 배열 이용시에는 큰 쪽에서 작은 쪽으로 탐색하며 물건을 용량 N~1일 때마다 넣어보고 최대값을 갱신함 
     - 역순으로 탐색해야하는 이유
       - 0/1 Knapsack 문제의 특성
       - 각 물건을 한 번만 사용할 수 있어, 현재 탐색 중인 물건을 여러 번 사용할 수 없도록 하기 위해
       - 역순으로 탐색함으로써, 현재 물건을 고려하기 전에 그 물건이 포함되지 않은 이전 상태의 DP 배열을 유지할 수 있습니다.